<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Memory Cards (Images)</title>

  <style>
    :root{
      --app-viewport-w: 100vw;
      --app-viewport-h: 100vh;

      --phone-w: 450px;
      --phone-h: 800px;
      --phone-scale: 1;

      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
      --safe-right: env(safe-area-inset-right);

      --bottom-bar-h: 200px;
      --bottom-shift: 18%;
      --bottom-safe-pad: 150px;

      --hud-shadow: 0 2px 0 rgba(0,0,0,.45), 0 10px 22px rgba(0,0,0,.25);

      /* размер символа внутри карточки */
      --symbol-inset: 10%;
      --symbol-max: 80%;
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      min-height: var(--app-viewport-h);
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:#0b0e12;
      overflow:hidden;
    }

    body{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
      background:
        radial-gradient(1200px 900px at 30% 15%, rgba(126,240,255,.12), transparent 50%),
        radial-gradient(1000px 800px at 75% 25%, rgba(255,208,126,.10), transparent 55%),
        radial-gradient(1200px 900px at 60% 90%, rgba(170,140,255,.10), transparent 55%),
        linear-gradient(180deg, #07090c, #0b0e12 30%, #06070a);
    }

    #app{
      width: var(--phone-w);
      height: var(--phone-h);
      max-width: 100vw;
      max-height: var(--app-viewport-h);
      transform: scale(var(--phone-scale));
      transform-origin: center center;
      border-radius: 32px;
      position: relative;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      box-shadow:
        0 35px 90px rgba(0,0,0,.65),
        0 10px 30px rgba(0,0,0,.45),
        inset 0 1px 0 rgba(255,255,255,.15),
        inset 0 -1px 0 rgba(0,0,0,.35);
    }

    #bg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      z-index:0;
      pointer-events:none;
    }

    /* HUD */
    #hud{
      position:absolute;
      top: calc(12px + var(--safe-top));
      left: calc(12px + var(--safe-left));
      right: calc(12px + var(--safe-right));
      z-index: 5;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      pointer-events:none;
    }

    /* слева — Raund Count.png */
    #stats{
      position:relative;
      width: 190px;
      height: 66px;
      border-radius: 16px;
      overflow:hidden;

      background: rgba(255,255,255,.08);            /* прозрачнее чем таймер */
      border: 1px solid rgba(255,255,255,.32);
      box-shadow: 0 16px 30px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.22);
      backdrop-filter: blur(8px);
    }
    #stats-bg{ display:none; }
    #stats-text{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      padding: 10px 12px;
      color: rgba(255,255,255,.96);
      font-weight: 900;
      line-height: 1.05;
      letter-spacing: .2px;
      text-shadow: var(--hud-shadow);
    }
    #stats-text .line{ font-size: 18px; }

    /* справа — таймер (СТЕКЛО) */
    #timer-wrap{
      position:relative;
      min-width: 124px;
      height: 54px;
      padding: 0 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 16px;

      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.32);
      box-shadow: 0 16px 30px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.22);
      backdrop-filter: blur(8px);
    }
    #timer{
      font-weight: 1000;
      font-size: 26px;
      letter-spacing: 1px;
      color: rgba(255,255,255,.97);
      text-shadow: var(--hud-shadow);
    }

    /* Stage */
    #stage{
      position:absolute;
      inset:0;
      z-index:1;
      padding-top: calc(12px + var(--safe-top) + 74px);
      padding-left: calc(12px + var(--safe-left));
      padding-right: calc(12px + var(--safe-right));
      padding-bottom: calc(12px + var(--safe-bottom) + var(--bottom-safe-pad));
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* панель под поле */
    #board-panel{
      position:relative;
      border-radius: 24px;
      background: rgba(255,255,255,.10);
      border: 2px solid rgba(255,255,255,.35);
      box-shadow:
        0 18px 55px rgba(0,0,0,.25),
        inset 0 1px 0 rgba(255,255,255,.22);
      backdrop-filter: blur(8px);
      padding: 18px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #board-panel::before{
      content:"";
      position:absolute;
      inset: 6px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.18);
      pointer-events:none;
    }

    #grid{
      display:grid;
      place-items:stretch;
      gap: 14px;
    }
    .grid-cell{
      width:100%;
      height:100%;
      aspect-ratio: 1 / 1;
    }

    /* карточки белые */
    .card{
      width:100%;
      height:100%;
      border:0;
      padding:0;
      background:transparent;
      cursor:pointer;
      perspective: 900px;
      border-radius: 16px;
      outline:none;
      -webkit-tap-highlight-color: transparent;
    }
    .card[disabled]{ cursor:default; opacity:.94; }

    .card-inner{
      position:relative;
      width:100%;
      height:100%;
      transform-style:preserve-3d;
      transition: transform .34s cubic-bezier(.2,.75,.25,1);
      border-radius: 16px;
    }
    .card.flipped .card-inner{ transform: rotateY(180deg); }

   .face{
      position:absolute;
      inset:0;
      backface-visibility:hidden;
      border-radius: 16px;
      overflow:hidden;

      background: rgba(255, 238, 155, 1);

      border: 2px solid rgba(255,255,255,.95);
      box-shadow:
        0 10px 22px rgba(0,0,0,.12),
        inset 0 1px 0 rgba(0,0,0,.06);
    }

    .symbol{
      position:absolute;
      inset: var(--symbol-inset);
      max-width: var(--symbol-max);
      max-height: var(--symbol-max);
      width:auto;
      height:auto;
      margin:auto;
      object-fit:contain;
      display:block;
      pointer-events:none;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.12));
      transform: scale(1.06);
    }

    .front{ transform: rotateY(180deg); }

    /* Bottom bar — стеклянная плашка как HUD */
    #bottom-bar{
      position:absolute;
      left:0; right:0; bottom:0;
      height: var(--bottom-bar-h);
      transform: translateY(var(--bottom-shift));
      z-index: 6;
      pointer-events:auto;

      border-top-left-radius: 28px;
      border-top-right-radius: 28px;
      overflow:hidden;

      /* стекло */
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.30);
      box-shadow:
        0 18px 55px rgba(0,0,0,.35),
        inset 0 1px 0 rgba(255,255,255,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);

      isolation:isolate; /* чтобы слои (before/after) не перекрывали контент */
    }
    #bottom-bar::before{
      content:"";
      position:absolute;
      left:10px; right:10px;
      top:10px; bottom:10px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.16);
      pointer-events:none;
      z-index:0;
    }
    #bottom-bar::after{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height: 40%;
      background: linear-gradient(180deg, rgba(255,255,255,.10), transparent);
      pointer-events:none;
      z-index:0;
    }

    #bottom-content{
      position:absolute;
      left:0; right:0;
      top:0;
      height: calc(100% - var(--bottom-shift));
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      padding:
        10px
        calc(14px + var(--safe-right))
        calc(12px + var(--safe-bottom))
        calc(14px + var(--safe-left));
      z-index:1; /* поверх before/after */
    }

    .bottom-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 14px;
      width:100%;
    }

    .imgbtn{
      border:0;
      padding:0;
      background:transparent;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .imgbtn img{
      height: 52px;
      width: auto;
      display:block;
      pointer-events:none;
      filter: drop-shadow(0 8px 10px rgba(0,0,0,.18));
    }

    /* WIN overlay */
    #overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10;
      padding: 18px;

      background: rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
    }
    #overlay.show{ display:flex; }

    #win-modal{
      position:relative;
      width: min(92%, 420px);
      aspect-ratio: 320 / 410;
      pointer-events:auto;
    }
    #win-frame{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      pointer-events:none;
      filter: drop-shadow(0 24px 70px rgba(0,0,0,.35));
    }

    /* контент поверх win frame */
    #win-content{
      position:absolute;
      inset:0;
      padding: 18px 18px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap: 10px;
      color: rgba(255,255,255,.98);
      text-shadow: var(--hud-shadow);

      transform: translateY(92px);
    }

    #win-title{
      margin-top: -10px;
      font-weight: 1000;
      font-size: 28px;
    }

    #win-sub{
      margin-top: -10px;
      font-weight: 900;
      font-size: 14px;
      opacity: .95;
    }

    #win-grid{
      margin-top: 30px;
      width: 92%;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .wcell{
      padding: 10px 12px;
      border-radius: 0;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      text-shadow: none;
    }

    .wcell .k{
      font-weight: 900;
      font-size: 14px;
      opacity: .98;
      color: rgba(255,255,255,.95);
    }

    .wcell .v{
      margin-top: 3px;
      font-weight: 1000;
      font-size: 20px;
      color: rgba(255,255,255,.98);
    }

    #tryagain-wrap{
      margin-top: 34px;
      display:flex;
      align-items:center;
      justify-content:center;
      width:100%;
    }

    @media (orientation: landscape){
      :root{
        --bottom-bar-h: 170px;
        --bottom-safe-pad: 120px;
      }
    }

    @media (max-height: 620px){
      :root{
        --bottom-bar-h: 180px;
        --bottom-safe-pad: 120px;
        --symbol-inset: 9%;
        --symbol-max: 82%;
      }
      #timer{ font-size: 24px; }
      .imgbtn img{ height: 48px; }
      #stats{ width: 180px; height: 62px; }
      #stats-text .line{ font-size: 17px; }
    }

    /* FIX: запрет выделения/перетаскивания */
    #app, #app *{
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    img, .card, .card *{
      -webkit-user-drag: none;
    }
    .card{ touch-action: manipulation; }
  </style>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>

<body>
  <div id="app">
    <img id="bg" alt="" />

    <div id="hud">
      <div id="stats">
        <img id="stats-bg" alt="" />
        <div id="stats-text">
          <div class="line">Ходов: <span id="moves">0</span></div>
          <div class="line">Отгадано: <span id="round">0/0</span></div>
        </div>
      </div>

      <div id="timer-wrap">
        <div id="timer">00:00</div>
      </div>
    </div>

    <div id="stage">
      <div id="board-panel">
        <div id="grid" aria-label="Cards grid"></div>
      </div>
    </div>

    <!-- bottom bar БЕЗ картинки -->
    <div id="bottom-bar" aria-label="Bottom menu">
      <div id="bottom-content">
        <div class="bottom-row">
          <button class="imgbtn" id="btn-easy"   type="button"><img alt="4x3" /></button>
          <button class="imgbtn" id="btn-medium" type="button"><img alt="4x4" /></button>
          <button class="imgbtn" id="btn-hard"   type="button"><img alt="6x4" /></button>
        </div>
        <div class="bottom-row">
          <button class="imgbtn" id="btn-restart" type="button"><img alt="Restart" /></button>
        </div>
      </div>
    </div>

    <!-- WIN -->
    <div id="overlay" role="dialog" aria-modal="true" aria-label="Win">
      <div id="win-modal">
        <img id="win-frame" alt="" />
        <div id="win-content">
          <div id="win-title">Победа!</div>
          <div id="win-sub">Clean flips. Perfect vibes.</div>

          <div id="win-grid">
            <div class="wcell"><div class="k">Время</div><div class="v" id="w-time">00:00</div></div>
            <div class="wcell"><div class="k">Ходов</div><div class="v" id="w-moves">0</div></div>
            <div class="wcell"><div class="k">Точность</div><div class="v" id="w-acc">0%</div></div>
            <div class="wcell"><div class="k">Сложность</div><div class="v" id="w-diff">Легкая</div></div>
          </div>

          <div id="tryagain-wrap">
            <button class="imgbtn" id="btn-tryagain" type="button" aria-label="Try Again">
              <img id="tryagain-img" alt="Ещё раз" />
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
(() => {
  const tg = (() => { try { return window.Telegram?.WebApp || null; } catch { return null; } })();
  if (tg) { try { tg.ready(); tg.expand?.(); } catch {} }

  const u = (p) => encodeURI(p);

  const ASSETS = {
    uiDir: './PNG/',
    cardsDir: './карточки/',

    bg: './фон.jpg',
    bgLandscape: './FomGoriz.jpg', // FIX: фон для горизонтали

    // рядом с html
    roundCount: './Raund Count.png',
    winFrame: './win frame.png',

    buttons: {
      easy:   { n: '4x3_button.png',     h: '4x3_button_Hover.png' },
      medium: { n: '4x4_button.png',     h: '4x4_button_Hover.png' },
      hard:   { n: '6x4_button.png',     h: '6x4_button_Hover.png' },
      restart:{ n: 'Restart_button.png', h: 'Restart_button_Hover.png' },
      tryAgain:{ n: 'TryAgain_button.png', h: 'TryAgain_button_Hover.png' },
    },

    cardNames: Array.from({length: 18}, (_, i) => {
      const num = String(i + 1).padStart(2, '0');
      return `карточка${num}.png`;
    }),
  };

  const el = {
    app: document.getElementById('app'),
    stage: document.getElementById('stage'),
    boardPanel: document.getElementById('board-panel'),
    grid: document.getElementById('grid'),

    bg: document.getElementById('bg'),
    bottomBar: document.getElementById('bottom-bar'), // FIX
    statsBg: document.getElementById('stats-bg'),

    moves: document.getElementById('moves'),
    round: document.getElementById('round'),
    timer: document.getElementById('timer'),

    btnEasyWrap: document.getElementById('btn-easy'),
    btnMediumWrap: document.getElementById('btn-medium'),
    btnHardWrap: document.getElementById('btn-hard'),
    btnRestartWrap: document.getElementById('btn-restart'),

    btnEasy: document.querySelector('#btn-easy img'),
    btnMedium: document.querySelector('#btn-medium img'),
    btnHard: document.querySelector('#btn-hard img'),
    btnRestart: document.querySelector('#btn-restart img'),

    overlay: document.getElementById('overlay'),
    winFrame: document.getElementById('win-frame'),
    wTime: document.getElementById('w-time'),
    wMoves: document.getElementById('w-moves'),
    wAcc: document.getElementById('w-acc'),
    wDiff: document.getElementById('w-diff'),

    btnTryAgain: document.getElementById('btn-tryagain'),
    tryAgainImg: document.getElementById('tryagain-img'),
  };

  function getViewportSize(){
    const vv = window.visualViewport;
    const height = Math.floor(tg?.viewportStableHeight ?? tg?.viewportHeight ?? vv?.height ?? window.innerHeight);
    const width  = Math.floor(tg?.viewportWidth ?? vv?.width ?? window.innerWidth);
    return { width: Math.max(320, width), height: Math.max(320, height) };
  }

  function updateViewportVars(){
    const { width, height } = getViewportSize();
    document.documentElement.style.setProperty('--app-viewport-w', `${width}px`);
    document.documentElement.style.setProperty('--app-viewport-h', `${height}px`);
  }

  const ua = navigator.userAgent || '';
  const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
  const isMobilePlatform = ['android', 'ios', 'mobile'].includes(tg?.platform);
  const isMobile = isMobileUA || isMobilePlatform;

  function resizePhoneScale(){
    const { width: viewportW, height: viewportH } = getViewportSize();
    const padding = isMobile ? 0 : 20;

    const safeW = Math.max(320, viewportW - padding * 2);
    const safeH = Math.max(320, viewportH - padding * 2);

    const landscape = viewportW > viewportH;

    if (isMobile){
      document.documentElement.style.setProperty('--phone-w', `${safeW}px`);
      document.documentElement.style.setProperty('--phone-h', `${safeH}px`);
      document.documentElement.style.setProperty('--phone-scale', landscape ? '0.90' : '1');
      return;
    }

    const preferLandscape = landscape;
    let width, height;

    if (preferLandscape){
      const aspect = 16 / 9;
      height = safeH;
      width = height * aspect;
      if (width > safeW){ width = safeW; height = width / aspect; }
      document.documentElement.style.setProperty('--phone-scale', '0.88');
    } else {
      width = safeW; height = safeH;
      document.documentElement.style.setProperty('--phone-scale', '1');
    }

    document.documentElement.style.setProperty('--phone-w', `${width}px`);
    document.documentElement.style.setProperty('--phone-h', `${height}px`);
  }

  const preload = (srcList) => Promise.all(srcList.map(src => new Promise((res) => {
    const img = new Image();
    img.onload = img.onerror = () => res(true);
    img.src = src;
  })));

  const DIFFS = {
    easy:   { cols: 4, rows: 3, label: 'Легкая'  },
    medium: { cols: 4, rows: 4, label: 'Средняя' },
    hard:   { cols: 6, rows: 4, label: 'Сложная' },
  };

  const game = {
    diff: 'easy',
    cols: 4,
    rows: 3,
    pairs: 6,

    started: false,
    locked: false,
    first: null,
    second: null,

    matchedPairs: 0,
    moves: 0,

    t0: 0,
    elapsed: 0,
    raf: 0,
  };

  function fmt(ms){
    const s = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(s / 60);
    const r = s % 60;
    return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
  }

  function updateHUD(){
    el.moves.textContent = String(game.moves);

    const totalCards = game.cols * game.rows;
    const foundCards = game.matchedPairs * 2;
    el.round.textContent = `${foundCards}/${totalCards}`;
  }

  function startTimer(){
    if (game.started) return;
    game.started = true;
    game.t0 = performance.now();
    const tick = (t) => {
      if (!game.started) return;
      game.elapsed = t - game.t0;
      el.timer.textContent = fmt(game.elapsed);
      game.raf = requestAnimationFrame(tick);
    };
    game.raf = requestAnimationFrame(tick);
  }

  function stopTimer(){
    game.started = false;
    if (game.raf) cancelAnimationFrame(game.raf);
    game.raf = 0;
  }

  function showWin(){
    stopTimer();

    const acc = game.moves > 0 ? Math.round((game.pairs / game.moves) * 100) : 0;

    el.wTime.textContent = fmt(game.elapsed);
    el.wMoves.textContent = String(game.moves);
    el.wAcc.textContent = `${acc}%`;
    el.wDiff.textContent = DIFFS[game.diff].label;

    el.overlay.classList.add('show');
    try { tg?.sendData?.('memory_cards_reward'); } catch {}
  }

  function hideWin(){ el.overlay.classList.remove('show'); }
  function setLocked(v){ game.locked = v; }

  function pickRandomFaces(countPairs){
    const pool = ASSETS.cardNames.slice();
    for (let i = pool.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, countPairs);
  }

  function buildDeck(){
    const faces = pickRandomFaces(game.pairs);
    const deck = [];
    faces.forEach((name, idx) => {
      const face = u(ASSETS.cardsDir + name);
      deck.push({ id: idx, face });
      deck.push({ id: idx, face });
    });
    for (let i = deck.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  }

  function layoutBoard(){
    const stageRect = el.stage.getBoundingClientRect();
    const barRect = el.bottomBar.getBoundingClientRect();

    const cs = getComputedStyle(el.stage);
    const padTop = parseFloat(cs.paddingTop) || 0;
    const padBottom = parseFloat(cs.paddingBottom) || 0;
    const padLeft = parseFloat(cs.paddingLeft) || 0;
    const padRight = parseFloat(cs.paddingRight) || 0;

    const contentW = Math.max(1, stageRect.width - padLeft - padRight);

    const contentTop = stageRect.top + padTop;
    const contentBottomNominal = stageRect.bottom - padBottom;

    const contentBottom = Math.min(contentBottomNominal, barRect.top - 10);
    const contentH = Math.max(1, contentBottom - contentTop);

    const ratio = contentW / Math.max(1, contentH);
    const wide = ratio > 1.20;

    const wMul = wide ? 0.74 : 0.96;
    const hMul = wide ? 0.74 : 0.96;

    const maxW = contentW * wMul;
    const maxH = contentH * hMul;

    const framePad = (game.cols >= 6 || wide) ? 12 : 18;
    const gap = (game.cols >= 6 || wide) ? 9 : 14;

    const availW = Math.max(80, maxW - framePad * 2);
    const availH = Math.max(80, maxH - framePad * 2);

    const cell = Math.floor(Math.min(
      (availW - gap * (game.cols - 1)) / game.cols,
      (availH - gap * (game.rows - 1)) / game.rows
    ));

    const cellClamped = Math.max(26, cell);

    const gridW = cellClamped * game.cols + gap * (game.cols - 1);
    const gridH = cellClamped * game.rows + gap * (game.rows - 1);

    el.grid.style.gap = `${gap}px`;
    el.grid.style.gridTemplateColumns = `repeat(${game.cols}, ${cellClamped}px)`;
    el.grid.style.gridTemplateRows = `repeat(${game.rows}, ${cellClamped}px)`;
    el.grid.style.width = `${gridW}px`;
    el.grid.style.height = `${gridH}px`;

    el.boardPanel.style.padding = `${framePad}px`;
    el.boardPanel.style.width = `${gridW + framePad * 2}px`;
    el.boardPanel.style.height = `${gridH + framePad * 2}px`;
  }

  function makeCard(cardDef){
    const btn = document.createElement('button');
    btn.className = 'card';
    btn.type = 'button';

    btn.draggable = false;
    btn.addEventListener('dragstart', (e) => e.preventDefault());

    const inner = document.createElement('div');
    inner.className = 'card-inner';

    const back = document.createElement('div');
    back.className = 'face back';

    const front = document.createElement('div');
    front.className = 'face front';

    const symbol = document.createElement('img');
    symbol.className = 'symbol';
    symbol.alt = '';
    symbol.src = cardDef.face;

    symbol.draggable = false;
    symbol.addEventListener('dragstart', (e) => e.preventDefault());

    front.appendChild(symbol);

    inner.appendChild(back);
    inner.appendChild(front);
    btn.appendChild(inner);

    btn.dataset.id = String(cardDef.id);
    btn.dataset.matched = '0';

    btn.addEventListener('click', () => onCardClick(btn));
    return btn;
  }

  function onCardClick(cardEl){
    if (game.locked) return;
    if (cardEl.dataset.matched === '1') return;
    if (cardEl.classList.contains('flipped')) return;

    startTimer();
    cardEl.classList.add('flipped');

    if (!game.first){
      game.first = cardEl;
      return;
    }

    game.second = cardEl;
    game.moves += 1;
    updateHUD();
    evaluatePair();
  }

  function evaluatePair(){
    if (!game.first || !game.second) return;

    setLocked(true);
    const a = game.first;
    const b = game.second;
    const match = a.dataset.id === b.dataset.id;

    window.setTimeout(() => {
      if (match){
        a.dataset.matched = '1';
        b.dataset.matched = '1';
        a.disabled = true;
        b.disabled = true;

        game.matchedPairs += 1;
        updateHUD();

        game.first = null;
        game.second = null;
        setLocked(false);

        if (game.matchedPairs >= game.pairs) showWin();
      } else {
        a.classList.remove('flipped');
        b.classList.remove('flipped');
        game.first = null;
        game.second = null;
        setLocked(false);
      }
    }, match ? 320 : 700);
  }

  function setupImgButton(btnWrap, imgEl, normalSrc, hoverSrc, { stickyActive = false, isActiveFn = null } = {}){
    const normal = u(ASSETS.uiDir + normalSrc);
    const hover  = u(ASSETS.uiDir + hoverSrc);

    const apply = (isHover) => {
      if (stickyActive && isActiveFn?.()) { imgEl.src = hover; return; }
      imgEl.src = isHover ? hover : normal;
    };

    apply(false);
    btnWrap.addEventListener('pointerenter', () => apply(true));
    btnWrap.addEventListener('pointerleave', () => apply(false));
    btnWrap.addEventListener('pointerdown', () => apply(true));
    btnWrap.addEventListener('pointerup',   () => apply(false));

    return {
      setActiveLook: () => { imgEl.src = hover; },
      setNormalLook: () => { imgEl.src = normal; },
    };
  }

  let btnEasyCtrl, btnMediumCtrl, btnHardCtrl;

  function setDifficultyActive(key){
    const map = { easy: btnEasyCtrl, medium: btnMediumCtrl, hard: btnHardCtrl };
    Object.entries(map).forEach(([k, ctrl]) => {
      if (!ctrl) return;
      if (k === key) ctrl.setActiveLook();
      else ctrl.setNormalLook();
    });
  }

  function rebuild(diffKey){
    hideWin();

    stopTimer();
    el.timer.textContent = '00:00';

    game.diff = diffKey ?? game.diff;
    const d = DIFFS[game.diff];
    game.cols = d.cols;
    game.rows = d.rows;
    game.pairs = (d.cols * d.rows) / 2;

    game.started = false;
    game.locked = false;
    game.first = null;
    game.second = null;
    game.matchedPairs = 0;
    game.moves = 0;
    game.elapsed = 0;

    updateHUD();

    el.grid.innerHTML = '';
    const deck = buildDeck();
    deck.forEach((def) => {
      const cell = document.createElement('div');
      cell.className = 'grid-cell';
      cell.appendChild(makeCard(def));
      el.grid.appendChild(cell);
    });

    setDifficultyActive(game.diff);

    layoutBoard();
    requestAnimationFrame(layoutBoard);
  }

  let currentBg = '';
  function setBgByOrientation(){
    const { width, height } = getViewportSize();
    const landscape = width > height;
    const src = u(landscape ? ASSETS.bgLandscape : ASSETS.bg);
    if (currentBg !== src){
      el.bg.src = src;
      currentBg = src;
    }
  }

  function initImages(){
    setBgByOrientation();

    el.winFrame.src = u(ASSETS.winFrame);

    btnEasyCtrl = setupImgButton(el.btnEasyWrap, el.btnEasy, ASSETS.buttons.easy.n, ASSETS.buttons.easy.h, {
      stickyActive:true, isActiveFn: () => game.diff === 'easy'
    });
    btnMediumCtrl = setupImgButton(el.btnMediumWrap, el.btnMedium, ASSETS.buttons.medium.n, ASSETS.buttons.medium.h, {
      stickyActive:true, isActiveFn: () => game.diff === 'medium'
    });
    btnHardCtrl = setupImgButton(el.btnHardWrap, el.btnHard, ASSETS.buttons.hard.n, ASSETS.buttons.hard.h, {
      stickyActive:true, isActiveFn: () => game.diff === 'hard'
    });

    setupImgButton(el.btnRestartWrap, el.btnRestart, ASSETS.buttons.restart.n, ASSETS.buttons.restart.h);

    setupImgButton(el.btnTryAgain, el.tryAgainImg, ASSETS.buttons.tryAgain.n, ASSETS.buttons.tryAgain.h);
  }

  function wireUI(){
    el.btnEasyWrap.addEventListener('click', () => rebuild('easy'));
    el.btnMediumWrap.addEventListener('click', () => rebuild('medium'));
    el.btnHardWrap.addEventListener('click', () => rebuild('hard'));
    el.btnRestartWrap.addEventListener('click', () => rebuild(game.diff));

    el.btnTryAgain.addEventListener('click', () => rebuild(game.diff));

    el.overlay.addEventListener('click', (e) => { if (e.target === el.overlay) hideWin(); });
  }

  function lockDragAndMenu(){
    const block = (e) => e.preventDefault();
    el.app.addEventListener('dragstart', block);
    el.app.addEventListener('dragover', block);
    el.app.addEventListener('drop', block);
    el.app.addEventListener('contextmenu', block);
  }

  const handleViewportChange = () => {
    updateViewportVars();
    resizePhoneScale();
    setBgByOrientation();
    layoutBoard();
  };

  window.addEventListener('resize', handleViewportChange, { passive:true });
  window.visualViewport?.addEventListener('resize', handleViewportChange, { passive:true });
  window.visualViewport?.addEventListener('scroll', handleViewportChange, { passive:true });
  tg?.onEvent?.('viewportChanged', handleViewportChange);

  (async function boot(){
    handleViewportChange();
    initImages();
    wireUI();
    lockDragAndMenu();

    const preloadList = [
      u(ASSETS.bg),
      u(ASSETS.bgLandscape),
      u(ASSETS.roundCount),
      u(ASSETS.winFrame),

      ...Object.values(ASSETS.buttons).flatMap(b => [u(ASSETS.uiDir + b.n), u(ASSETS.uiDir + b.h)]),
      ...ASSETS.cardNames.map(n => u(ASSETS.cardsDir + n)),
    ];
    await preload(preloadList);

    rebuild('easy');
  })();
})();
</script>
</body>
</html>
